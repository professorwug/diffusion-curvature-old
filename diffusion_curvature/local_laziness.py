# AUTOGENERATED! DO NOT EDIT! File to edit: ../02b_region_limited_laziness.ipynb.

# %% auto 0
__all__ = ['local_laziness']

# %% ../02b_region_limited_laziness.ipynb 4
from tqdm.notebook import trange
import numpy as np
def local_laziness(A, diffusion_powers = 8, aperture = 80, neighborhood = 1, dynamically_adjusting_neighborhood = False, smoothing=1, verbose=False):
    """Take a localized measure of diffusion laziness, with diffusion restricted to with the given aperture. Estimates curvature.

    Parameters
    ----------
    A : ndarray
        Affinity matrix of data (non-row normalized)
    diffusion_powers : int, optional
        The number of matrix powers to raise the diffusion operature, by default 8
    aperture : int, optional
        The number of nearest neighbors to which to limit the diffusion operator, by default 80
    neighborhood : int, optional
        The number of nearest neighbors of a point to use calculating laziness, by default 1
    dynamically_adjusting_neighborhood : bool, optional
        Whether the aperture and neighborhood should be based on thresholds derived over the dataset (False) or should expand to create the designated number of neighbors everywhere in the dataset (if True), by default False
    smoothing : int, optional
        Number of iterations of diffusion averaging to apply to the laziness values before returning, by default 1
    verbose : bool, optional
        Whether to print debugging statements and return extra debugging information, by default True

    Returns
    -------
    list
        Laziness value at each point
    """
    # First, a proof of concept: iterate through every point,
    # Make a sub-diffusion matrix for that point, consisting only of the nearest neighbors, 
    # And calculate the laziness for each value
    laziness_values = []
    # debugging
    list_of_apertures = []
    list_of_Ps = []
    list_of_Wsubs = []
    for i in trange(A.shape[0]):
        # Get the indices of the "aperture" closest points, as measured by the diffusion probabilities
        idxs = np.argsort(A[i])[-aperture:][::-1]
        # TODO Should these be sorted? Does it matter?
        # Create a sub-diffusion matrix. The pt i should be first.
        W_sub = A[idxs][:,idxs]
        degrees = np.diag(1/np.sum(W_sub,axis=1))
        P = degrees @ W_sub
        # Derive thresholds for the neighborhood partition
        # TODO Could reuse above idxs for greater efficiency
        thresholds = np.partition(P,-neighborhood)[:,-neighborhood]
        P_threshold = np.mean(thresholds) # TODO could also use min
        P_thresholded = (P >= P_threshold).astype(int)
        # Power the matrix
        P_powered = np.linalg.matrix_power(P,diffusion_powers)
        # take the diffusion probs of the neighborhood
        near_neighbors_only = P_powered * P_thresholded
        laziness_aggregate = np.sum(near_neighbors_only,axis=1)
        laziness_of_point = laziness_aggregate[0] 
        laziness_values.append(laziness_of_point)
        list_of_apertures.append(idxs)
        list_of_Ps.append(P_powered)
        list_of_Wsubs.append(W_sub)
    # Smoothing
    if smoothing is not None:  
        D = np.diag(1/np.sum(A,axis=1))
        P = D @ A 
        P_t = np.linalg.matrix_power(P,smoothing)
        ks_smoothed = P_t @ laziness_values
        laziness_values = ks_smoothed.squeeze()
    if verbose:
        return laziness_values, list_of_apertures, list_of_Ps, list_of_Wsubs
    return laziness_values

