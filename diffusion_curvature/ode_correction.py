# AUTOGENERATED! DO NOT EDIT! File to edit: ../08c_sampling_learned_by_ode.ipynb.

# %% auto 0
__all__ = ['single_point_diffusion_curvature_contra_neural_flattening']

# %% ../08c_sampling_learned_by_ode.ipynb 20
from sklearn.decomposition import PCA
def single_point_diffusion_curvature_contra_neural_flattening(X, idx, dimension, t=8, k=10, n_neighbors = 100):
    # prepare neighborhood
    central_point = X[idx]
    # TODO: We presently assume that these neighborhoods are small enough that euclidean similarities are accurate
    distances_to_central_point = torch.linalg.norm(X - central_point, axis=1)
    neighbor_idxs = np.argpartition(distances_to_central_point,n_neighbors)[:n_neighbors]
    ambient_points = X[neighbor_idxs]
    pca = PCA(n_components=dimension)
    pca_points = pca.fit_transform(ambient_points.numpy())
    pca_points = scaler.fit_transform(pca_points)
    pca_points = torch.Tensor(pca_points)
    
