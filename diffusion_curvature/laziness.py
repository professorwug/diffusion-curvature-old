# AUTOGENERATED! DO NOT EDIT! File to edit: 04_region_limited_laziness.ipynb (unless otherwise specified).

__all__ = ['curvature', 'laziness_decay', 'local_laziness']

# Cell
import numpy as np
def curvature(P, diffusion_powers=8, aperture = 20, smoothing=1, verbose = False, return_density = False, dynamically_adjusting_neighborhood = False, precomputed_powered_P = None, non_lazy_diffusion=False, restrict_diffusion_to_k_neighborhood=None, avg_transition_probability=True, use_min_threshold = False):
    """Diffusion Laziness Curvature
    Estimates curvature by measuring the amount of mass remaining within an initial neighborhood after t steps of diffusion. Akin to measuring the laziness of a random walk after t steps.

    Parameters
    ----------
    P : n x n ndarray
        The diffusion matrix of the graph
    diffusion_powers : int, optional
        Number of steps of diffusion to take before measuring the laziness, by default 8
    aperture : int, optional
        The size of the initial neighborhood, from which the percentage of mass remaining in this neighborhood is calculated, by default 20
    smoothing : int, optional
        Amount of smoothing to apply. Currently works by multiplying the raw laziness values with the diffusion operator, as a kind of iterated weighted averaging; by default 1
    verbose : bool, optional
        Print diagnostics, by default False
    return_density : bool, optional
        Return the number of neighbors each point shares, by default False
    dynamically_adjusting_neighborhood : bool, optional
        Whether to give each point the same initial neighborhood size, by default False
    precomputed_powered_P : ndarray, optional
        Optionally pass a precomputed powered diffusion operator, to speed up computation, by default None
    avg_transition_probability: bool, default True
        Use the definition of diffusion curvature in which the summed transition probabilities are divided by the total number of points in the aperture neighborhood.
        As a result, gives not the summed "return probability within the neighborhood" but the average return probability to each point in the aperture neighborhood.
        This formulation of diffusion curvature was used in proof given in our NeurIPS 2022 paper.

    Returns
    -------
    length n array
        The laziness curvature values for each point
    """
    # the aperture sets the size of the one-hop neighborhood
    # the aperture parameter is the average number of neighbors to include, based off of the sorted diffusion values
    # Set thresholds as the kth largest diffusion value, presumed to be held by the kth nearest neighbor.
    thresholds = np.partition(P,-aperture)[:,-aperture]
    # thresholds = np.sort(P)[:,-aperture]
    if verbose: print(thresholds)
    if dynamically_adjusting_neighborhood:
        P_thresholded = (P >= thresholds[:,None]).astype(int)
    else:
        if use_min_threshold:
            P_threshold = np.min(thresholds)
        else:
            P_threshold = np.mean(thresholds) # TODO could also use min
        P_thresholded = (P >= P_threshold).astype(int)
        if verbose: print("Derived threshold ",P_threshold)

    if verbose: print(np.sum(P_thresholded,axis=1))
    if verbose: print("Performing matrix powers...")

    if precomputed_powered_P is not None:
        P_powered = precomputed_powered_P
    elif non_lazy_diffusion:
        print("Removing self-diffusion")
        P_zero_diagonal = (np.ones_like(P) - np.diag(np.ones(len(P))))*P
        D = np.diag(1/np.sum(P_zero_diagonal,axis=0))
        P = D @ P_zero_diagonal
        P_powered = np.linalg.matrix_power(P,diffusion_powers)
    else:
        P_powered = np.linalg.matrix_power(P,diffusion_powers)
    # take the diffusion probs of the neighborhood
    near_neighbors_only = P_powered * P_thresholded
    laziness_aggregate = np.sum(near_neighbors_only,axis=1)
    if avg_transition_probability:
        ones_matrix = np.ones_like(P_thresholded)
        ones_remaining = ones_matrix * P_thresholded
        local_density = np.sum(ones_remaining,axis=1)
        if verbose: print("local density",local_density)
        # divide by the number of neighbors diffused to
        # TODO: In case of isolated points, replace local density of 0 with 1. THe laziness will evaluate to zero.
        local_density[local_density==0]=1
        laziness_aggregate = laziness_aggregate / local_density
    laziness = laziness_aggregate
    if smoothing: # TODO there are probably more intelligent ways to do this smoothing
        # Local averaging to counter the effects local density
        if verbose: print("Applying smoothing...")
        smoothing_P_powered = np.linalg.matrix_power(P,smoothing)
        average_laziness = smoothing_P_powered @ laziness_aggregate[:,None]
        average_laziness = average_laziness.squeeze()
        laziness = average_laziness
    if return_density:
        # compute sums of neighbors taken into consideration
        ones_matrix = np.ones_like(P_thresholded)
        ones_remaining = ones_matrix * P_thresholded
        local_density = np.sum(ones_remaining,axis=1)
        return laziness, local_density
    return laziness

# Cell
from tqdm.notebook import trange
def laziness_decay(A, max_steps = 32, aperture = 20, neighborhood=10, smoothing=1, adaptive_neighborhood = False, non_lazy_diffusion=False,use_local_laziness=False):
    """Generates a matrix of the decaying laziness value per point over a range of t values

    Parameters
    ----------
    P : ndarray
        Diffusion matrix
    max_steps : int, optional
        Number of diffusion steps to take (starting from 1), by default 32
    aperture : int, optional
        The size of the initial diffusion neighborhood, by default 20
    smoothing : int, optional
        Number of smmoothing interations, by default 1

    Returns
    -------
    ndarray
        Each column is a set of laziness values per point at a specific time.
    """
    if A.sum(axis=1)[0]==1:
        print("You seem to have passed the diffusion matrix. Skipping row normalization.")
        P = A
    else:
        D = np.diag(1/np.sum(A,axis=1))
        P = D @ A
    decay_per_point = np.empty((len(P),max_steps))
    if non_lazy_diffusion:
        print("Removing self-diffusion")
        P_zero_diagonal = (np.ones_like(P) - np.diag(np.ones(len(P))))*P
        D = np.diag(1/np.sum(P_zero_diagonal,axis=0))
        P = D @ P_zero_diagonal
    P_t = P
    for t in trange(1,max_steps+1):
        if use_local_laziness:
            laziness = local_laziness(A,diffusion_powers = t,aperture=aperture,neighborhood=neighborhood,smoothing=1)
        else:
            P_t = P_t @ P
            laziness = curvature(P,diffusion_powers=t,aperture=aperture,precomputed_powered_P=P_t,smoothing=smoothing,dynamically_adjusting_neighborhood=adaptive_neighborhood, non_lazy_diffusion=non_lazy_diffusion)
        decay_per_point[:,t-1] = laziness
    return decay_per_point

# Cell
from tqdm.notebook import trange
def local_laziness(A, diffusion_powers = 8, aperture = 80, neighborhood = 1, dynamically_adjusting_neighborhood = False, smoothing=1, verbose=True):
    """Take a localized measure of diffusion laziness, with diffusion restricted to with the given aperture. Estimates curvature.

    Parameters
    ----------
    A : ndarray
        Affinity matrix of data (non-row normalized)
    diffusion_powers : int, optional
        The number of matrix powers to raise the diffusion operature, by default 8
    aperture : int, optional
        The number of nearest neighbors to which to limit the diffusion operator, by default 80
    neighborhood : int, optional
        The number of nearest neighbors of a point to use calculating laziness, by default 1
    dynamically_adjusting_neighborhood : bool, optional
        Whether the aperture and neighborhood should be based on thresholds derived over the dataset (False) or should expand to create the designated number of neighbors everywhere in the dataset (if True), by default False
    smoothing : int, optional
        Number of iterations of diffusion averaging to apply to the laziness values before returning, by default 1
    verbose : bool, optional
        Whether to print debugging statements and return extra debugging information, by default True

    Returns
    -------
    list
        Laziness value at each point
    """
    # First, a proof of concept: iterate through every point,
    # Make a sub-diffusion matrix for that point, consisting only of the nearest neighbors,
    # And calculate the laziness for each value
    laziness_values = []
    # debugging
    list_of_apertures = []
    list_of_Ps = []
    list_of_Wsubs = []
    for i in trange(A.shape[0]):
        # Get the indices of the "aperture" closest points, as measured by the diffusion probabilities
        idxs = np.argsort(A[i])[-aperture:][::-1]
        # TODO Should these be sorted? Does it matter?
        # Create a sub-diffusion matrix. The pt i should be first.
        W_sub = A[idxs][:,idxs]
        degrees = np.diag(1/np.sum(W_sub,axis=1))
        P = degrees @ W_sub
        # Derive thresholds for the neighborhood partition
        # TODO Could reuse above idxs for greater efficiency
        thresholds = np.partition(P,-neighborhood)[:,-neighborhood]
        P_threshold = np.mean(thresholds) # TODO could also use min
        P_thresholded = (P >= P_threshold).astype(int)
        # Power the matrix
        P_powered = np.linalg.matrix_power(P,diffusion_powers)
        # take the diffusion probs of the neighborhood
        near_neighbors_only = P_powered * P_thresholded
        laziness_aggregate = np.sum(near_neighbors_only,axis=1)
        laziness_of_point = laziness_aggregate[0]
        laziness_values.append(laziness_of_point)
        list_of_apertures.append(idxs)
        list_of_Ps.append(P_powered)
        list_of_Wsubs.append(W_sub)
    # Smoothing
    if smoothing is not None:
        D = np.diag(1/np.sum(A,axis=1))
        P = D @ A
        P_t = np.linalg.matrix_power(P,smoothing)
        ks_smoothed = P_t @ laziness_values
        laziness_values = ks_smoothed.squeeze()
    if verbose:
        return laziness_values, list_of_apertures, list_of_Ps, list_of_Wsubs
    return laziness_values

