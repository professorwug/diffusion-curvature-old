# AUTOGENERATED! DO NOT EDIT! File to edit: ../Wasserstein Diffusion Curvature.ipynb.

# %% auto 0
__all__ = ['wasserstein_spread_of_diffusion_matrix', 'get_manifold_distances', 'WassersteinDiffusionCurvature']

# %% ../Wasserstein Diffusion Curvature.ipynb 3
def wasserstein_spread_of_diffusion_matrix(
    P, # Diffusion matrix
    D, # Distance matrix
):
    w1_spread_of_diff = np.sum(P*D,axis=1)
    return w1_spread_of_diff    

# %% ../Wasserstein Diffusion Curvature.ipynb 5
import phate
from sklearn.metrics import pairwise_distances

def get_manifold_distances(
    method:str = "PHATE", # Choices: PHATE
    manifold_dim:int = 2, # intrinsic dimension of data
    X:np.ndarray=None, # Points, if available
    A:np.ndarray=None, # affinity graph, if available
    k:int=10, # num neighbors when constructing binary graph for shortest paths
):
    match method:
        case "PHATE":
            phate_op = phate.PHATE(n_components=manifold_dim)
            phate_coords = phate_op.fit_transform(X)
            D = pairwise_distances(phate_coords)
        case "shortest path":
            import networkx as nx
            from sklearn.neighbors import NearestNeighbors
            knn = NearestNeighbors(n_neighbors=5, metric='euclidean')
            knn.fit(X)
            A = knn.kneighbors_graph()
            G_nx = nx.from_numpy_array(A)
            D = nx.floyd_warshall_numpy(G_nx)
        case _:
            raise NotImplementedError(f"Unknown manifold distance method {method}")
    return D

# %% ../Wasserstein Diffusion Curvature.ipynb 7
from .datasets import *
class WassersteinDiffusionCurvature(): #TODO: Factor out some of this into a superclass that can share code & functionality with the entropic dc
    def __init__(self,
        t=8,
        k=10, # nearest neighbor parameter for kernel
        manifold_distance_method="PHATE",
        curvature_type="comparison",
        manifold_dimension="auto", # if auto, estimates with skdim DANCo. 
        average_curvature=False,
    ):
        store_attr()
        
    def curvature_of_points(self,
        X:np.ndarray, # pointcloud
        num_holes:int=None, # if using gauss bonnet method, must specify
    ):
        self.X = X
        self.A = gaussian_kernel(X, kernel_type="adaptive",k=self.k)
        return self.curvature_of_graph(num_holes=num_holes)
        
    def curvature_of_graph(self,
        A:np.ndarray=None,
        num_holes:int=None, # if using gauss bonnet method, must specify
    ):
        if A: self.A = A
        self.P = compute_anisotropic_diffusion_matrix_from_graph(self.A, alpha=1)
        self.Pt = np.linalg.matrix_power(self.P,self.t)
        self.D = get_manifold_distances(X=self.X, A=self.A, method=self.manifold_distance_method, k=self.k)
        self.wasserstein_spreads = wasserstein_spread_of_diffusion_matrix(self.Pt,self.D)
        if self.average_curvature:
            self.wasserstein_spreads = self.P @ self.wasserstein_spreads
        match self.curvature_type:
            case "ollivier":
                self.jumps = wasserstein_spread_of_diffusion_matrix(self.P,self.D)
                self.ks = 1 - self.wasserstein_spreads/(self.t * self.jumps)
            case "comparison":
                if self.manifold_dimension == "auto":
                    import skdim
                    danco = skdim.id.DANCo().fit(self.X)
                    self.manifold_dimension = danco.dimension_
                # TODO: Could reduce this boilerplate by instantiating the class inside of itself!
                X_comp = np.vstack([np.zeros(self.manifold_dimension),2*np.random.rand(len(self.A)-1,self.manifold_dimension)-1])
                A_comp = gaussian_kernel(X_comp, kernel_type="adaptive",k=self.k)
                P_comp = compute_anisotropic_diffusion_matrix_from_graph(A_comp, alpha=1)
                Pt_comp = np.linalg.matrix_power(P_comp,self.t)        
                D_comp = get_manifold_distances(X=X_comp, A=A_comp, method=self.manifold_distance_method, k = self.k)
                wasserstein_spreads_comp = np.sum(Pt_comp[0]*D_comp[0])
                # compute difference
                self.ks = wasserstein_spreads_comp - self.wasserstein_spreads
            case "gauss bonnet":
                euler_char = 2 - 2*num_holes
                c = (np.sum(1/self.wasserstein_spreads) - 2*np.pi*euler_char)/(len(self.wasserstein_spreads))
                self.ks = 1/self.wasserstein_spreads - c
            case _:
                raise NotImplementedError
        return self.ks
    
    def plot(self):
        plot_3d(X,self.ks,colorbar=True)
        
