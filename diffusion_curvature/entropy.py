# AUTOGENERATED! DO NOT EDIT! File to edit: ../Diffusion Entropy Curvature.sync-conflict-20230727-071559-NXPHTTX.ipynb.

# %% auto 0
__all__ = ['local_diffusion_entropy_of_matrix', 'diffusion_entropy_curvature_of_data', 'diffusion_entropy_of_noise',
           'diffusion_curvature_contra_noise']

# %% ../Diffusion Entropy Curvature.sync-conflict-20230727-071559-NXPHTTX.ipynb 4
import numpy as np
from scipy.stats import entropy
from .core import gaussian_kernel
from .gaussian_invariance import compute_anisotropic_diffusion_matrix_from_graph
def local_diffusion_entropy_of_matrix(
    P:np.ndarray, # diffusion matrix
    t:int # time step to compute entropy at
    ) -> np.ndarray:
    """Computes the pointwise entropy of the t-step diffusion, a proxy for curvature"""
    P_t = np.linalg.matrix_power(P,t)
    entropies = np.array([entropy(x) for x in P_t])
    return entropies
def diffusion_entropy_curvature_of_data(
        X:np.ndarray, # data points, in shape n x d
        t:int=8, # time steps of diffusion
        k:int=10, # number of neighbors to use in calculating kernel
        **kwargs
        )->np.ndarray:
    A = gaussian_kernel(X, kernel_type="adaptive",k=k)
    P = compute_anisotropic_diffusion_matrix_from_graph(A, alpha=1)
    entropies = local_diffusion_entropy_of_matrix(P,t=t)
    return entropies

# %% ../Diffusion Entropy Curvature.sync-conflict-20230727-071559-NXPHTTX.ipynb 12
def diffusion_entropy_of_noise(dimension, t, n_flat_samples) -> float:
    # construct uniform noise, with one zero point at the center
    noisy_flat = np.random.rand(n_flat_samples-1, dimension)*2 - 1
    noisy_flat = np.vstack([np.zeros(dimension),noisy_flat])
    # note that the edges of this distribution aren't trustworthy; we only care about the middle
    # so we'll take just the entropy of the random noise
    entropy_flat = diffusion_entropy_curvature_of_data(noisy_flat, t = t)
    # TODO: This is ridiculously wasteful. It computes the curvature of every point, when we only need
    # the central point.
    # At least average over some points
    return entropy_flat[0]

def diffusion_curvature_contra_noise(X, dimension, t=8, k=10) -> np.ndarray:
    k_data = diffusion_entropy_curvature_of_data(X, t=t)
    k_noise = diffusion_entropy_of_noise(dimension, t=t, n_flat_samples=len(X))
    return k_noise - k_data
